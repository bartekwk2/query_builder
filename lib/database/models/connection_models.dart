import 'sql_values.dart';

enum SqlDatabase {
  mysql,
  postgres,
  sqlite,
}

class SqlQuery {
  final String query;
  final List<String> params;

  const SqlQuery(this.query, this.params);
}

abstract class TableConnection {
  const TableConnection();
  SqlDatabase get database;

  Future<SqlQueryResult> query(
    String sqlQuery, [
    List<Object?>? values,
  ]);

  Future<T> transaction<T>(Future<T> Function(TransactionCtx) transactionFn);

  Future<SqlQueryResult> select(
    String tableName,
    List<String> selects, {
    SqlValue<SqlBoolValue>? where,
    List<SqlOrderItem>? orderBy,
    SqlLimit? limit,
    List<String>? groupBy,
    List<SqlJoin>? join,
    bool unsafe = false,
  }) async {
    final sqlQuery = selectSql(
      tableName,
      selects,
      where: where,
      limit: limit,
      orderBy: orderBy,
    );

    return query(sqlQuery.query, sqlQuery.params);
    // int _refIndex = 3;

    // return result.map((r) {
    //   return Room(
    //     codeRoom: r[0] as String,
    //     section: r[1] as int,
    //     createdAt: r[2] as DateTime,
    //   );
    // }).toList();
  }

  SqlQuery selectSql(
    String tableName,
    List<String> selects, {
    SqlValue<SqlBoolValue>? where,
    List<SqlOrderItem>? orderBy,
    SqlLimit? limit,
    List<String>? groupBy,
    List<SqlJoin>? join,
    bool unsafe = false,
  }) {
// ${withRoom ? ",JSON_ARRAYAGG(JSON_OBJECT('codeRoom',room.code_room,'section',room.section,'createdAt',room.created_at)) refRoom" : ""}
// ${withUser ? ",JSON_ARRAYAGG(JSON_OBJECT('codeUser',user.code_user,'createdAt',user.created_at)) refUser" : ""}
// ${withTypeMessage ? ",JSON_ARRAYAGG(JSON_OBJECT('codeType',type_message.code_type,'createdAt',type_message.created_at)) refTypeMessage" : ""}

// ${withRoom ? "JOIN room ON message.room_code=room.code_room AND message.room_code_section=room.section" : ""}
// ${withUser ? "JOIN user ON message.user_code=user.code_user" : ""}
// ${withTypeMessage ? "JOIN type_message ON message.type_message_code=type_message.code_type" : ""}

    final ctx = SqlContext(database: database, unsafe: unsafe);
    final query = """
SELECT ${selects.join(',')}
FROM $tableName
${join == null ? '' : join.map((e) => e.toSql(ctx)).join('\n')}
${where == null ? '' : 'WHERE ${where.toSql(ctx)}'}
${groupBy == null ? '' : 'GROUP BY ${groupBy.join(',')}'}
${orderBy == null ? '' : 'ORDER BY ${orderBy.map((item) => item.toSql(ctx)).join(",")}'}
${limit == null ? '' : 'LIMIT ${limit.rowCount} ${limit.offset == null ? "" : "OFFSET ${limit.offset}"}'}
;""";
    return SqlQuery(query, ctx.variables);
  }
}

abstract class SqlQueryResult implements Iterable<SqlRow> {
  int? get affectedRows;
  int? get insertId;
}

abstract class SqlRow implements Map<String, dynamic> {
  Object? columnAt(int index);
  List<Object?>? get columnsValues;

  /// Returns a two-level map that on the first level contains the resolved
  /// table name, and on the second level the column name (or its alias).
  Map<String?, Map<String, dynamic>> toTableColumnMap();
}

/// Thrown by sqlite methods.
///
/// This is the only exception thrown by `package:sqlite3`. Additionally, errors
/// might be thrown on api misuse.
class SqlException implements Exception {
  final Object originalException;

  /// An error message indicating what went wrong.
  final String message;

  /// Additional details if provided by the database.
  // String? detail;
  // /// A hint on how to remedy an error, if provided by the database.
  // String? hint;

  /// A five character ANSI SQLSTATE value
  // final String sqlState;
  /// An optional explanation providing more detail on what went wrong.
  final String? explanation;

  /// The MySQL error number
  /// SQLite extended result code.
  ///
  /// As defined in https://sqlite.org/rescode.html, it represents an error
  /// code, providing some idea of the cause of the failure.
  final int code;

  /// The PostgreSQL error code.
  ///
  /// May be null if the exception was not generated by the database.
  final String? codeStr;

  /// SQLite primary result code.
  ///
  /// As defined in https://sqlite.org/rescode.html, it represents an error
  /// code, providing some idea of the cause of the failure.
  // int get resultCode => extendedResultCode & 0xFF;

  /// The SQL statement triggering this exception.
  ///
  /// This may be null when no prior statement is known.
  final String? causingStatement;

  final String? severity;

  /// A [StackTrace] if available.
  final StackTrace? stackTrace;

  SqlException({
    required this.originalException,
    required this.code,
    required this.message,
    this.codeStr,
    this.explanation,
    this.causingStatement,
    this.severity,
    this.stackTrace,
  });

  @override
  String toString() => originalException.toString();
}

abstract class TransactionCtx extends TableConnection {
  const TransactionCtx();
  Never rollback();

  factory TransactionCtx.fromConnection(
    TableConnection conn, {
    required Never Function() rollback,
  }) = TransactionCtxValue;
}

class TransactionCtxValue extends TransactionCtx with TableConnectionMixin {
  @override
  final TableConnection connection;
  final Never Function() _rollback;

  TransactionCtxValue(
    this.connection, {
    required Never Function() rollback,
  }) : _rollback = rollback;

  @override
  Future<T> transaction<T>(Future<T> Function(TransactionCtx) transactionFn) {
    return transactionFn(this);
  }

  @override
  Never rollback() => _rollback();
}

mixin TableConnectionMixin on TableConnection {
  TableConnection get connection;

  @override
  SqlDatabase get database => connection.database;

  @override
  Future<SqlQueryResult> query(String sqlQuery, [List<Object?>? values]) {
    return connection.query(sqlQuery, values);
  }

  @override
  Future<T> transaction<T>(Future<T> Function(TransactionCtx) transactionFn) {
    return connection.transaction(transactionFn);
  }
}
